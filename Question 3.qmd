# Question 3

```{r}
# Gibbs Sampler for Bayesian Linear Regression with Outliers
library(MASS)       # For multivariate normal sampling
library(truncnorm)  # For truncated normal (used for truncated Gamma via inverse transform)
library(mvtnorm)

bayes_lm_gibbs_trunc <- function(
    X, Y, n1, n2,
    prior_beta_mean = NULL, 
    prior_beta_variance, #T0 
    a = 1, b = 1,
    n_iter = 5000, burn_in = 1000,
    thin = 2
) {
  # Dimensions
  n <- nrow(X)
  p <- ncol(X)
  
  # Default prior for beta: N(0, 100I)
  if (is.null(prior_beta_mean)) prior_beta_mean <- rep(0, p)
  prior_beta_cov <- diag(p) * prior_beta_variance
  
  # Initialize storage
  total_iter <- burn_in + (n1 + n2) * thin
  beta_samples <- matrix(0, n_iter, p)
  tau1_samples <- numeric(n_iter)
  tau2_samples <- numeric(n_iter)
  
  # Initial values
  beta <- rep(0, p)
  tau1 <- as.numeric(var(Y))
  tau2 <- tau1 * 2 # Since assumption is that tau1 < tau2
  sample_count <- 0
  
  # Split data into standard (I1) and outlier (I2) groups
  X1 <- X[1:n1, , drop = FALSE]
  X2 <- X[(n1 + 1):(n1 + n2), , drop = FALSE]
  Y1 <- Y[1:n1]
  Y2 <- Y[(n1 + 1):(n1 + n2)]
  
  # Gibbs sampling loop
  for (iter in 1:total_iter) {
    # --- Sample beta ---
    Sigma_beta_inv <- tau1 * t(X1) %*% X1 + tau2 * t(X2) %*% X2 + solve(prior_beta_cov)
    Sigma_beta <- solve(Sigma_beta_inv)
    mu_beta <- Sigma_beta %*% (tau1 * t(X1) %*% X1 + tau2 * t(X2) %*% X2)
    beta <- mvtnorm::rmvnorm(1, mean = mu_beta[1,],sigma =  Sigma_beta)
    # Error with mu beta not being one vector
    
    # --- Sample tau1 ---
    residuals1 <- Y1 - X1 %*% t(beta) # not t(beta) and not x1 
    shape_tau1 <- a + n1 / 2
    rate_tau1 <- b + sum(residuals1^2) / 2
    tau1 <- rgamma(1, shape = shape_tau1, rate = rate_tau1)
    
    # --- Sample tau2 (truncated: tau2 < tau1) ---
    residuals2 <- Y2 - X2 %*% t(beta)
    shape_tau2 <- a + n2 / 2
    rate_tau2 <- b + sum(residuals2^2) / 2
    
    # Inverse CDF method for truncated Gamma
    u <- runif(1, 0, pgamma(tau1, shape_tau2, rate_tau2))
    tau2 <- qgamma(u, shape_tau2, rate_tau2)
    
    # Store samples
        # Store samples after burn-in and with thinning
    if (iter > burn_in && (iter - burn_in) %% thin == 0) {
      sample_count <- sample_count + 1
      beta_samples[sample_count, ] <- beta
      tau1_samples[sample_count] <- tau1
      tau2_samples[sample_count] <- tau2
    }
  }
  
  # Return results as a list
  list(
    beta_samples = beta_samples,
    tau1_samples = tau1_samples,
    tau2_samples = tau2_samples
    )
}
```

```{r}
# Example usage:
set.seed(123)
n <- 100
p <- 5
X <- cbind(1, matrix(rnorm(n*(p-1)), n, p-1))
true_beta <- c(1, 2, -1, 3, 5 )
Y <- X %*% true_beta + rnorm(n)

# Prior parameters
T0 <- diag(1, p)  # Prior precision for beta
a <- 0.1; b <- 0.1  # Gamma prior parameters

# Run Gibbs sampler
results <- bayes_lm_gibbs_trunc(X=X, Y=Y, n1 = n*0.8, n2 = n*0.2, prior_beta_variance = 2, a=a, b=b)
results

# Check results
colMeans(results$beta_samples)  # Posterior means of beta
mean(results$tau1_samples)     # Posterior mean of tau1
mean(results$tau2_samples)     # Posterior mean of tau2
```
